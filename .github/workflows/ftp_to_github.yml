name: Update Shimano FTP feed (robust)

on:
  schedule:
    - cron: "0 2 * * *"   # denně 02:00 UTC (~03:00 Praha v CET)
  workflow_dispatch:      # ruční spuštění

permissions:
  contents: write

concurrency:
  group: azfishingcz-shimano-feed
  cancel-in-progress: true

jobs:
  fetch_and_commit:
    runs-on: ubuntu-latest
    env:
      PYTHONUNBUFFERED: "1"
      FTP_FILE_NAME: "ArtExpPLNF_Baltic.txt"  # název na FTP
      TARGET_DIR: "feed"                      # složka v repu
      TARGET_NAME: "ArtExpPLNF_Baltic.txt"    # název v repu
      TMP_FILE: "tmp_download.txt"

    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Download file from FTP (FTP→FTPS fallback)
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_PASS: ${{ secrets.FTP_PASS }}
        run: |
          python - <<'PY'
          import os, io, sys
          from ftplib import FTP, FTP_TLS, all_errors

          host = os.environ["FTP_HOST"]
          user = os.environ["FTP_USER"]
          pw   = os.environ["FTP_PASS"]
          name = os.environ["FTP_FILE_NAME"]
          outp = os.environ["TMP_FILE"]

          def log(x): print(x, flush=True)

          def try_mode(mode):
              try:
                  if mode == "FTP_PASV":
                      ftp = FTP(host, timeout=60); ftp.login(user, pw); ftp.set_pasv(True); return ftp, mode
                  if mode == "FTPS_PASV":
                      ftp = FTP_TLS(host, timeout=60); ftp.login(user, pw); ftp.prot_p(); ftp.set_pasv(True); return ftp, mode
                  if mode == "FTP_ACTIVE":
                      ftp = FTP(host, timeout=60); ftp.login(user, pw); ftp.set_pasv(False); return ftp, mode
                  if mode == "FTPS_ACTIVE":
                      ftp = FTP_TLS(host, timeout=60); ftp.login(user, pw); ftp.prot_p(); ftp.set_pasv(False); return ftp, mode
              except all_errors as e:
                  log(f"CONNECT_FAIL[{mode}]: {e}")
              return None, mode

          log(f"START: host={host} user={user} target={name}")
          ftp = None
          for m in ["FTP_PASV","FTPS_PASV","FTP_ACTIVE","FTPS_ACTIVE"]:
              ftp, used = try_mode(m)
              if ftp:
                  log(f"OK CONNECT: {used}")
                  break
          if not ftp:
              log("ERROR: Cannot connect FTP/FTPS in any mode.")
              sys.exit(10)

          buf = io.BytesIO()
          try:
              ftp.retrbinary(f"RETR {name}", buf.write)
          except all_errors as e:
              log(f"RETR_FAIL: {e}")
              try:
                  ftp.quit()
              except Exception:
                  pass
              sys.exit(11)

          data = buf.getvalue()
          with open(outp, "wb") as f:
              f.write(data)
          log(f"OK DOWNLOAD: {len(data)} bytes -> {outp}")

          try:
              ftp.quit()
          except Exception:
              pass
          PY

      - name: Prepare feed branch and decide if changed
        id: prep
        env:
          TARGET_DIR: ${{ env.TARGET_DIR }}
          TARGET_NAME: ${{ env.TARGET_NAME }}
          TMP_FILE: ${{ env.TMP_FILE }}
        run: |
          set -e

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch remote refs
          git fetch origin --prune

          # Switch/create local feed branch from remote if exists
          if git ls-remote --exit-code --heads origin feed >/dev/null 2>&1; then
            if git show-ref --verify --quiet refs/heads/feed; then
              git checkout feed
            else
              git checkout -b feed origin/feed
            fi
          else
            git checkout -b feed
          fi

          mkdir -p "${TARGET_DIR}"
          DEST="${TARGET_DIR}/${TARGET_NAME}"

          # Compute checksums (if old file exists)
          NEW_SHA=$(sha256sum "${TMP_FILE}" | awk '{print $1}')
          if [ -f "${DEST}" ]; then
            OLD_SHA=$(sha256sum "${DEST}" | awk '{print $1}')
          else
            OLD_SHA="__missing__"
          fi

          echo "new_sha=${NEW_SHA}" >> $GITHUB_OUTPUT
          echo "old_sha=${OLD_SHA}" >> $GITHUB_OUTPUT

          if [ "${NEW_SHA}" = "${OLD_SHA}" ]; then
            echo "No content change detected. Skipping commit."
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          mv -f "${TMP_FILE}" "${DEST}"
          git add "${DEST}"
          echo "changed=true" >> $GITHUB_OUTPUT

      - name: Commit & push (robust with retries)
        if: steps.prep.outputs.changed == 'true'
        env:
          TARGET_DIR: ${{ env.TARGET_DIR }}
          TARGET_NAME: ${{ env.TARGET_NAME }}
        run: |
          set -e

          git commit -m "update: ${TARGET_NAME} $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

          # Up to 5 attempts:
          # 1-3: normal push with rebase pull on rejection
          # 4:   rebase again and try push
          # 5:   last resort: --force-with-lease
          attempt=1
          while [ $attempt -le 5 ]; do
            echo "Push attempt #$attempt"

            if git push origin feed; then
              echo "Push OK"
              break
            fi

            echo "Push rejected. Fetch & rebase, then retry..."
            git fetch origin --prune || true
            git pull --rebase origin feed || true

            if [ $attempt -eq 4 ]; then
              echo "Last normal retry failed, next try will use --force-with-lease."
            fi

            if [ $attempt -eq 5 ]; then
              echo "Using --force-with-lease (last resort)"
              git push --force-with-lease origin feed
              echo "Push forced OK"
              break
            fi

            attempt=$((attempt+1))
            # exponenciální backoff
            sleep $((attempt*2))
          done

      - name: Print RAW URL for Sheets
        env:
          REPO: ${{ github.repository }}
          TARGET_DIR: ${{ env.TARGET_DIR }}
          TARGET_NAME: ${{ env.TARGET_NAME }}
        run: |
          echo "RAW URL:"
          echo "https://raw.githubusercontent.com/${REPO}/feed/${TARGET_DIR}/${TARGET_NAME}"
